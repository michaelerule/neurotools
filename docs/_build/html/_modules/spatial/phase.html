

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>spatial.phase &mdash; Neurotools 2 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> Neurotools
          

          
          </a>

          
            
            
              <div class="version">
                2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">neurotools</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Neurotools</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>spatial.phase</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for spatial.phase</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/python</span>
<span class="c1"># -*- coding: UTF-8 -*-</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Statistics routines to examine population statistics of phases and</span>
<span class="sd">complex-valued (phase,amplitude) analytic signals.</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">with_statement</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">nested_scopes</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">generators</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">unicode_literals</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">neurotools.signal</span> <span class="k">import</span> <span class="n">rewrap</span>

<span class="n">ELECTRODE_SPACING</span> <span class="o">=</span> <span class="mf">0.4</span>

<div class="viewcode-block" id="population_kuramoto"><a class="viewcode-back" href="../../spatial.phase.html#spatial.phase.population_kuramoto">[docs]</a><span class="k">def</span> <span class="nf">population_kuramoto</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Compute the Kuramoto order parameter of a population of complex-</span>
<span class="sd">    valued phase oscillators. </span>
<span class="sd">    </span>
<span class="sd">    If an array is provided, the average is taken over the first array</span>
<span class="sd">    dimension unless</span>
<span class="sd">    otherwise specified.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pop : np.array</span>
<span class="sd">        Array of complex-valued phases of a population of phase oscillators.</span>
<span class="sd">        Expectations are taken over the first dimension only unless</span>
<span class="sd">        otherwise specified.</span>
<span class="sd">    </span>
<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    axis : int, default 0</span>
<span class="sd">        Axis over which to operate</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float or np.array</span>
<span class="sd">        Kuramotor order parameter of the population</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">pop</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">pop</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">))</span></div>

<div class="viewcode-block" id="population_synchrony"><a class="viewcode-back" href="../../spatial.phase.html#spatial.phase.population_synchrony">[docs]</a><span class="k">def</span> <span class="nf">population_synchrony</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Estimate phase-oscillator population synchrony. This is similar to </span>
<span class="sd">    the Kuramoto order parameter, but weights each oscillator by its </span>
<span class="sd">    amplitude. Since signal measurements typically have nonzero noise, </span>
<span class="sd">    phase estimates from low-amplitude oscillators are less reliable. </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pop : np.array</span>
<span class="sd">        Array of complex-valued phases of a population of phase oscillators.</span>
<span class="sd">        Expectations are taken over the first dimension only unless</span>
<span class="sd">        otherwise specified.</span>
<span class="sd">    </span>
<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    axis : int, default 0</span>
<span class="sd">        Axis over which to operate</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float or np.array</span>
<span class="sd">        Oscillator synchrony over the population</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">))</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">pop</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span></div>

<div class="viewcode-block" id="population_polar_std"><a class="viewcode-back" href="../../spatial.phase.html#spatial.phase.population_polar_std">[docs]</a><span class="k">def</span> <span class="nf">population_polar_std</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    The circular standard deviation of a collection of phase oscillators.</span>
<span class="sd">    This is a transformation of `population_synchrony` with units of </span>
<span class="sd">    radians, which is easier to interpret. </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pop : np.array</span>
<span class="sd">        Array of complex-valued phases of a population of phase oscillators.</span>
<span class="sd">        Expectations are taken over the first dimension only unless</span>
<span class="sd">        otherwise specified.</span>
<span class="sd">    </span>
<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    axis : int, default 0</span>
<span class="sd">        Axis over which to operate</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float or np.array</span>
<span class="sd">        Circular standard deviation over the population</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">population_synchrony</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)))</span></div>

<div class="viewcode-block" id="population_average_amplitude"><a class="viewcode-back" href="../../spatial.phase.html#spatial.phase.population_average_amplitude">[docs]</a><span class="k">def</span> <span class="nf">population_average_amplitude</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Compute the average absolute amplitude of a population of complex-</span>
<span class="sd">    valued phase oscillators.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pop : np.array</span>
<span class="sd">        Array of complex-valued phases of a population of phase oscillators.</span>
<span class="sd">        Expectations are taken over the first dimension only unless</span>
<span class="sd">        otherwise specified.</span>
<span class="sd">    </span>
<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    axis : int, default 0</span>
<span class="sd">        Axis over which to operate</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float or np.array</span>
<span class="sd">        Average amplitude over the population</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">pop</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span></div>

<div class="viewcode-block" id="population_signal_dispersion"><a class="viewcode-back" href="../../spatial.phase.html#spatial.phase.population_signal_dispersion">[docs]</a><span class="k">def</span> <span class="nf">population_signal_dispersion</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    A standardized measure of the dispersion of a population of complex-</span>
<span class="sd">    valued phase oscillators. Computes the determinant of the covariance</span>
<span class="sd">    matrix describing the 2D distribution of (phases, amplitudes) in the</span>
<span class="sd">    complex plane, raised to the 1/4th power. This has the same units as</span>
<span class="sd">    the linear dimension of the signal. For example, if the underlying </span>
<span class="sd">    signals are in mV, then this is a standard measure of how dispersed</span>
<span class="sd">    the analytic signals are in the complex plane, also in mV. </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pop : np.array</span>
<span class="sd">        Array of complex-valued phases of a population of phase oscillators.</span>
<span class="sd">        Expectations are taken over the first dimension only unless</span>
<span class="sd">        otherwise specified.</span>
<span class="sd">    </span>
<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    axis : int, default 0</span>
<span class="sd">        Axis over which to operate</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float or np.array</span>
<span class="sd">        Depending on whether a 1D or ND array was passed</span>
<span class="sd">        Standardized measure of dispersion</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">r</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">pop</span><span class="p">)</span>
    <span class="n">i</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">pop</span><span class="p">)</span>
    <span class="n">r</span>   <span class="o">=</span> <span class="n">r</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">i</span>   <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="c1"># Compute covariances</span>
    <span class="n">Crr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">r</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">Cri</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">i</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">Cii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">i</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="c1"># Compute determinent</span>
    <span class="n">Det</span> <span class="o">=</span> <span class="n">Crr</span><span class="o">*</span><span class="n">Cii</span><span class="o">-</span><span class="n">Cri</span><span class="o">**</span><span class="mi">2</span>
    <span class="k">return</span> <span class="n">Det</span><span class="o">**</span><span class="mf">0.25</span></div>

<div class="viewcode-block" id="population_signal_concentration"><a class="viewcode-back" href="../../spatial.phase.html#spatial.phase.population_signal_concentration">[docs]</a><span class="k">def</span> <span class="nf">population_signal_concentration</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Returns a standardized, unitless measure of the concentration of a</span>
<span class="sd">    population of complex-valued (phase,amplitude) oscillators. </span>
<span class="sd">    This is analagous to the reciprocal of the coefficient of variation</span>
<span class="sd">    for univariate data. Larger values indicate more precise distributions.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pop : np.array</span>
<span class="sd">        Array of complex-valued phases of a population of phase oscillators.</span>
<span class="sd">        Expectations are taken over the first dimension only unless</span>
<span class="sd">        otherwise specified.</span>
<span class="sd">    </span>
<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    axis : int, default 0</span>
<span class="sd">        Axis over which to operate</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float or np.array</span>
<span class="sd">        Depending on whether a 1D or ND array was passed</span>
<span class="sd">        Standardized measure of concentration</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">population_average_amplitude</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span><span class="o">/</span><span class="n">population_signal_dispersion</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span></div>

<div class="viewcode-block" id="population_signal_precision"><a class="viewcode-back" href="../../spatial.phase.html#spatial.phase.population_signal_precision">[docs]</a><span class="k">def</span> <span class="nf">population_signal_precision</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Returns 1/σ where σ=population_signal_dispersion is a standardized</span>
<span class="sd">    measure of the dispersion in the population.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pop : np.array</span>
<span class="sd">        Array of complex-valued phases of a population of phase oscillators.</span>
<span class="sd">        Expectations are taken over the first dimension only unless</span>
<span class="sd">        otherwise specified.</span>
<span class="sd">        </span>
<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    axis : int, default 0</span>
<span class="sd">        Axis over which to operate</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float or np.array</span>
<span class="sd">        Depending on whether a 1D or ND array was passed</span>
<span class="sd">        Standardized measure of precision</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">population_signal_dispersion</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="population_signal_phase_dispersion"><a class="viewcode-back" href="../../spatial.phase.html#spatial.phase.population_signal_phase_dispersion">[docs]</a><span class="k">def</span> <span class="nf">population_signal_phase_dispersion</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Coefficient of variation of phases, estimated using a local </span>
<span class="sd">    linearization around the mean phase. </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pop : np.array</span>
<span class="sd">        Array of complex-valued phases of a population of phase oscillators.</span>
<span class="sd">        Expectations are taken over the first dimension only unless </span>
<span class="sd">        otherwise specified.</span>
<span class="sd">        </span>
<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    axis : int, default 0</span>
<span class="sd">        Axis over which to operate</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float or np.array</span>
<span class="sd">        Depending on whether a 1D or ND array was passed</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># rotate into best-guess zero phase reference frame</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="n">z</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z</span><span class="p">))</span><span class="o">**-</span><span class="mi">1</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">pop</span><span class="o">*</span><span class="n">h</span>
    <span class="c1"># phase dispersion is CV=sig/mu deviation along the imaginary axis</span>
    <span class="c1"># the mean is always zero so we don&#39;t normalize it</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">real</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">s</span><span class="o">/</span><span class="n">m</span></div>

<div class="viewcode-block" id="population_signal_phase_std"><a class="viewcode-back" href="../../spatial.phase.html#spatial.phase.population_signal_phase_std">[docs]</a><span class="k">def</span> <span class="nf">population_signal_phase_std</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Standard deviation of phases locally linearized around the mean </span>
<span class="sd">    phase</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pop : np.array</span>
<span class="sd">        Array of complex-valued phases of a population of phase oscillators.</span>
<span class="sd">        Expectations are taken over the first dimension only unless</span>
<span class="sd">        otherwise specified.</span>
<span class="sd">        </span>
<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    axis : int, default 0</span>
<span class="sd">        Axis over which to operate</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float or np.array</span>
<span class="sd">        Depending on whether a 1D or ND array was passed</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># rotate into best-guess zero phase reference frame</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="n">z</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z</span><span class="p">))</span><span class="o">**-</span><span class="mi">1</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">pop</span><span class="o">*</span><span class="n">h</span>
    <span class="c1"># phase dispersion is CV=sig/mu deviation along the imaginary axis</span>
    <span class="c1"># the mean is always zero so we don&#39;t normalize it</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">std</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">s</span></div>

<div class="viewcode-block" id="population_signal_amplitude_std"><a class="viewcode-back" href="../../spatial.phase.html#spatial.phase.population_signal_amplitude_std">[docs]</a><span class="k">def</span> <span class="nf">population_signal_amplitude_std</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Standard deviation of amplitudes locally linearized around the mean</span>
<span class="sd">    phase</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pop : np.array</span>
<span class="sd">        Array of complex-valued phases of a population of phase oscillators.</span>
<span class="sd">        Expectations are taken over the first dimension only unless</span>
<span class="sd">        otherwise specified.</span>
<span class="sd">        </span>
<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    axis : int, default 0</span>
<span class="sd">        Axis over which to operate</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float or np.array</span>
<span class="sd">        Depending on whether a 1D or ND array was passed</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># rotate into best-guess zero phase reference frame</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="n">z</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z</span><span class="p">))</span><span class="o">**-</span><span class="mi">1</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">pop</span><span class="o">*</span><span class="n">h</span><span class="p">)</span>
    <span class="c1"># amplitude dispersion is CV=sig/mu deviation along the real axis</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">real</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">s</span></div>

<div class="viewcode-block" id="population_signal_amplitude_dispersion"><a class="viewcode-back" href="../../spatial.phase.html#spatial.phase.population_signal_amplitude_dispersion">[docs]</a><span class="k">def</span> <span class="nf">population_signal_amplitude_dispersion</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Coefficient of variation of amplitudes, locally linearized around</span>
<span class="sd">    the mean phase</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pop : np.array</span>
<span class="sd">        Array of complex-valued phases of a population of phase oscillators.</span>
<span class="sd">        Expectations are taken over the first dimension only unless</span>
<span class="sd">        otherwise specified.</span>
<span class="sd">        </span>
<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    axis : int, default 0</span>
<span class="sd">        Axis over which to operate</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float or np.array</span>
<span class="sd">        Depending on whether a 1D or ND array was passed</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># rotate into best-guess zero phase reference frame</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="n">z</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z</span><span class="p">))</span><span class="o">**-</span><span class="mi">1</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">pop</span><span class="o">*</span><span class="n">h</span><span class="p">)</span>
    <span class="c1"># amplitude dispersion is CV=sig/mu deviation along the real axis</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">s</span><span class="o">/</span><span class="n">m</span></div>

<div class="viewcode-block" id="population_signal_phase_precision"><a class="viewcode-back" href="../../spatial.phase.html#spatial.phase.population_signal_phase_precision">[docs]</a><span class="k">def</span> <span class="nf">population_signal_phase_precision</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Inverse coefficient of variation of phases, estimated using a local </span>
<span class="sd">    linearization around the mean phase. </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pop : pop of oscillator phases; 1D np.complex array</span>
<span class="sd">        </span>
<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    axis : int, default 0</span>
<span class="sd">        Axis over which to operate</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float or np.array</span>
<span class="sd">        Depending on whether a 1D or ND array was passed</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="mf">1.</span><span class="o">/</span><span class="n">population_signal_phase_dispersion</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span></div>

<div class="viewcode-block" id="population_signal_amplitude_precision"><a class="viewcode-back" href="../../spatial.phase.html#spatial.phase.population_signal_amplitude_precision">[docs]</a><span class="k">def</span> <span class="nf">population_signal_amplitude_precision</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Inverse coefficient of variation of amplitudes, estimated using a local </span>
<span class="sd">    linearization around the mean phase. </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pop : np.array</span>
<span class="sd">        Array of complex-valued phases of a population of phase oscillators.</span>
<span class="sd">        Expectations are taken over the first dimension only unless</span>
<span class="sd">        otherwise specified.</span>
<span class="sd">        </span>
<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    axis : int, default 0</span>
<span class="sd">        Axis over which to operate</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float or np.array</span>
<span class="sd">        Depending on whether a 1D or ND array was passed</span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="mf">1.</span><span class="o">/</span><span class="n">population_signal_amplitude_dispersion</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span></div>

<div class="viewcode-block" id="population_signal_description"><a class="viewcode-back" href="../../spatial.phase.html#spatial.phase.population_signal_description">[docs]</a><span class="k">def</span> <span class="nf">population_signal_description</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Returns a statistical of a population of complex-valued phase </span>
<span class="sd">    oscillators.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pop : np.array</span>
<span class="sd">        Array of complex-valued phases of a population of phase oscillators.</span>
<span class="sd">        Expectations are taken over the first dimension only unless</span>
<span class="sd">        otherwise specified.</span>
<span class="sd">        </span>
<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    axis : int, default 0</span>
<span class="sd">        Axis over which to operate</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    z : complex</span>
<span class="sd">        Average analytic signals</span>
<span class="sd">    a : float</span>
<span class="sd">        Magnitude of average analytic signal</span>
<span class="sd">    h : float</span>
<span class="sd">        Mean phase</span>
<span class="sd">    s1 : </span>
<span class="sd">        Standard deviation of linearized phases</span>
<span class="sd">    s2 : </span>
<span class="sd">        Standard deviation of linearized amplitudes</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">z</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">a</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
    <span class="n">h</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
    <span class="n">w</span>  <span class="o">=</span> <span class="n">pop</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">h</span><span class="p">)</span>
    <span class="n">s1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">w</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">s2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">w</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">return</span> </div>

<div class="viewcode-block" id="population_synchrony_linear"><a class="viewcode-back" href="../../spatial.phase.html#spatial.phase.population_synchrony_linear">[docs]</a><span class="k">def</span> <span class="nf">population_synchrony_linear</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Transformed population synchrony score</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pop : np.array</span>
<span class="sd">        Array of complex-valued phases of a population of phase oscillators.</span>
<span class="sd">        Expectations are taken over the first dimension only unless</span>
<span class="sd">        otherwise specified.</span>
<span class="sd">        </span>
<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    axis : int, default 0</span>
<span class="sd">        Axis over which to operate</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.array</span>
<span class="sd">        1/(1-population_synchrony(pop))</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">syn</span> <span class="o">=</span> <span class="n">population_synchrony</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">return</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">syn</span><span class="p">)</span></div>

<span class="c1"># we need a new measure of sliding coherence which extracts the median</span>
<span class="c1"># hilbert frequency and uses it to unwrap the phase. This is important</span>
<span class="c1"># because it will allow us to distinguish traveling waves from synch</span>
<span class="c1"># </span>

<div class="viewcode-block" id="population_phase_coherence"><a class="viewcode-back" href="../../spatial.phase.html#spatial.phase.population_phase_coherence">[docs]</a><span class="k">def</span> <span class="nf">population_phase_coherence</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Extracts median frequency. Uses this to unwrap array phases.</span>
<span class="sd">    Applies a per-channel phase shift to zero mean phase. </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : array-like</span>
<span class="sd">        No. of channels × No. of timepoints</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.array</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    ::</span>
<span class="sd">    </span>
<span class="sd">        s,a,tr = (&#39;SPK120918&#39;, &#39;M1&#39;, 16)</span>
<span class="sd">        pop  = get_all_analytic_pop(s,a,tr,epoch=(6,-1000,2001),fa=10,fb=45)</span>
<span class="sd">        data = pop[:,500:600]</span>
<span class="sd">        sliding = np.array([population_phase_coherence(pop[:,i:i+100]) for i in range(shape(pop)[1]-100)])</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;data should be a 2D np.array of phases, type np.complex&#39;</span><span class="p">)</span>
    <span class="n">h</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">dfdt</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">%</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="n">mdf</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">dfdt</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">dfdt</span><span class="o">-</span><span class="n">mdf</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="analytic_signal_coherence"><a class="viewcode-back" href="../../spatial.phase.html#spatial.phase.analytic_signal_coherence">[docs]</a><span class="k">def</span> <span class="nf">analytic_signal_coherence</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">window</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">hanning</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Extracts median frequency. Uses this to unwrap array phases.</span>
<span class="sd">    Applies a per-channel phase shift to zero mean phase. </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : array-like</span>
<span class="sd">        K x N</span>
<span class="sd">        K = No. of channels</span>
<span class="sd">        N = No. of timepoints</span>
<span class="sd">    L : </span>
<span class="sd">        Window length in samples, optional, default is 100</span>
<span class="sd">    window : function</span>
<span class="sd">        windowing function, optional, default is `np.hanning`</span>
<span class="sd">        </span>
<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    axis : int, default 0</span>
<span class="sd">        Axis over which to operate</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.array</span>
<span class="sd">    </span>
<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    ::</span>
<span class="sd">    </span>
<span class="sd">        s,a,tr = (&#39;SPK120918&#39;, &#39;M1&#39;, 16)</span>
<span class="sd">        pop = get_all_analytic_pop(s,a,tr,epoch=(6,-1000,2001),fa=10,fb=45)</span>
<span class="sd">        data = pop[:,500:600]</span>
<span class="sd">        sliding = np.array([population_signal_coherence(pop[:,i:i+100]) for i in range(shape(pop)[1]-100)])</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;data should be a 2D np.array of phases, type np.complex&#39;</span><span class="p">)</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">dfdt</span>     <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">%</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="n">mdf</span>      <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">dfdt</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">weights</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">data</span><span class="p">)[:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">weights</span>  <span class="o">=</span> <span class="n">weights</span><span class="o">*</span><span class="n">window</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">weights</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">dfdt</span><span class="o">-</span><span class="n">mdf</span><span class="p">)</span><span class="o">*</span><span class="n">weights</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="population_sliding_signal_coherence"><a class="viewcode-back" href="../../spatial.phase.html#spatial.phase.population_sliding_signal_coherence">[docs]</a><span class="k">def</span> <span class="nf">population_sliding_signal_coherence</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">L</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span><span class="n">window</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">hanning</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Extracts median frequency. Uses this to unwrap array phases.</span>
<span class="sd">    Applies a per-channel phase shift to zero mean phase. </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : array-like</span>
<span class="sd">        K x N</span>
<span class="sd">        K = No. of channels</span>
<span class="sd">        N = No. of timepoints</span>
<span class="sd">        </span>
<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    axis : int, default 0</span>
<span class="sd">        Axis over which to operate</span>
<span class="sd">    L : </span>
<span class="sd">        Window length in samples, optional, default is 100</span>
<span class="sd">    window : function</span>
<span class="sd">        windowing function, optional, default is `np.hanning`</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.array : </span>
<span class="sd">        Sliding-window Kuramoto order parameter over data</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;data should be a 2D np.array of phases, type np.complex&#39;</span><span class="p">)</span>
    <span class="n">N</span>       <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">h</span>       <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">dfdt</span>    <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">%</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">win</span>     <span class="o">=</span> <span class="n">window</span><span class="p">(</span><span class="n">L</span><span class="o">+</span><span class="mi">2</span><span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">slide</span>   <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">N</span><span class="o">-</span><span class="n">L</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">now</span> <span class="o">=</span> <span class="n">dfdt</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">L</span><span class="p">]</span>
        <span class="n">mdf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">now</span><span class="p">)</span>
        <span class="n">w</span>   <span class="o">=</span> <span class="n">weights</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">L</span><span class="p">]</span><span class="o">*</span><span class="n">win</span>
        <span class="n">w</span>  <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="n">slide</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">now</span><span class="o">-</span><span class="n">mdf</span><span class="p">)</span><span class="o">*</span><span class="n">w</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">slide</span><span class="p">)</span></div>

<span class="n">sliding_population_signal_coherence</span> <span class="o">=</span> <span class="n">population_sliding_signal_coherence</span>

<div class="viewcode-block" id="population_normalized_sliding_signal_coherence"><a class="viewcode-back" href="../../spatial.phase.html#spatial.phase.population_normalized_sliding_signal_coherence">[docs]</a><span class="k">def</span> <span class="nf">population_normalized_sliding_signal_coherence</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">L</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span><span class="n">window</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">hanning</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Extracts median frequency. Uses this to unwrap array phases.</span>
<span class="sd">    Applies a per-channel phase shift to zero mean phase. </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : array-like</span>
<span class="sd">        K x N</span>
<span class="sd">        K = No. of channels</span>
<span class="sd">        N = No. of timepoints</span>
<span class="sd">    L : </span>
<span class="sd">        Window length in samples, optional, default is 100</span>
<span class="sd">    window : function</span>
<span class="sd">        windowing function, optional, default is `np.hanning`</span>
<span class="sd">        </span>
<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    axis : int, default 0</span>
<span class="sd">        Axis over which to operate</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.array</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;data should be a 2D np.array of phases, type np.complex&#39;</span><span class="p">)</span>
    <span class="n">N</span>       <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">h</span>       <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">dfdt</span>    <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">%</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">win</span>     <span class="o">=</span> <span class="n">window</span><span class="p">(</span><span class="n">L</span><span class="o">+</span><span class="mi">2</span><span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">slide</span>   <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">N</span><span class="o">-</span><span class="n">L</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">now</span> <span class="o">=</span> <span class="n">dfdt</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">L</span><span class="p">]</span>
        <span class="n">mdf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">now</span><span class="p">)</span>
        <span class="n">w</span>   <span class="o">=</span> <span class="n">weights</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">L</span><span class="p">]</span><span class="o">*</span><span class="n">win</span>
        <span class="n">w</span>  <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="n">mu</span><span class="p">,</span><span class="n">sig</span> <span class="o">=</span> <span class="n">weighted_avg_and_std</span><span class="p">(</span> <span class="p">(</span><span class="n">now</span><span class="o">-</span><span class="n">mdf</span><span class="p">)</span><span class="o">/</span><span class="n">mdf</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="n">slide</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">slide</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span></div>

<div class="viewcode-block" id="population_phase_relative_sliding_kuramoto"><a class="viewcode-back" href="../../spatial.phase.html#spatial.phase.population_phase_relative_sliding_kuramoto">[docs]</a><span class="k">def</span> <span class="nf">population_phase_relative_sliding_kuramoto</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">L</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span><span class="n">window</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">hanning</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Uses the phase of each channel in the middle of each block as a</span>
<span class="sd">    reference point. Separates coherent wave activity from synchrony.</span>

<span class="sd">    .. math::</span>
<span class="sd">    </span>
<span class="sd">        \\textrm{kuramoto order} = \left\langle z/|z| \\right\\rangle</span>
<span class="sd">    </span>
<span class="sd">    Assumes constant phase velocity, and a constant per-channel</span>
<span class="sd">    phase shift, and then computes the order. This is a notion of </span>
<span class="sd">    relative phase stability.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : np.array</span>
<span class="sd">        Phase data as np.complex</span>
<span class="sd">        </span>
<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    L : int, default is 100</span>
<span class="sd">        Window length in samples</span>
<span class="sd">    window : function, default is `np.hanning`</span>
<span class="sd">        windowing function, optional</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.array</span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;data should be a 2D np.array of phases, type np.complex&#39;</span><span class="p">)</span>
    <span class="n">K</span><span class="p">,</span><span class="n">N</span>     <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">phases</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">phased</span>  <span class="o">=</span> <span class="n">data</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">dfdt</span>    <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">phases</span><span class="p">,</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">%</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="n">win</span>     <span class="o">=</span> <span class="n">window</span><span class="p">(</span><span class="n">L</span><span class="o">+</span><span class="mi">2</span><span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">win</span>     <span class="o">=</span> <span class="n">win</span><span class="o">/</span><span class="p">(</span><span class="n">K</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">win</span><span class="p">))</span>
    <span class="n">slide</span>   <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">N</span><span class="o">-</span><span class="n">L</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="c1"># get the median phase velocity</span>
        <span class="n">mf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">dfdt</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">L</span><span class="p">])</span>
        <span class="c1"># get the local phases</span>
        <span class="n">x</span>  <span class="o">=</span> <span class="n">phases</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">L</span><span class="p">]</span>
        <span class="c1"># dephase the signal in time</span>
        <span class="n">y</span>  <span class="o">=</span> <span class="n">rewrap</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">([</span><span class="n">mf</span><span class="p">]</span><span class="o">*</span><span class="n">L</span><span class="p">))</span>
        <span class="c1"># dephase the signal per channel</span>
        <span class="n">z</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">y</span><span class="p">),</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">rephased</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">T</span><span class="o">-</span><span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="c1"># compute weighted phase order</span>
        <span class="n">slide</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">rephased</span><span class="p">)</span><span class="o">*</span><span class="n">win</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">slide</span><span class="p">)</span></div>

<div class="viewcode-block" id="population_median_phase_velocity"><a class="viewcode-back" href="../../spatial.phase.html#spatial.phase.population_median_phase_velocity">[docs]</a><span class="k">def</span> <span class="nf">population_median_phase_velocity</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    median phase velocity.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : np.array</span>
<span class="sd">        2D array of phases; Nchannels x Ntimes</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    medv : np.array</span>
<span class="sd">        Median phase velocity within the population for every time point</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;data should be a 2D np.array of phases, type np.complex&#39;</span><span class="p">)</span>
    <span class="n">N</span>       <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">h</span>       <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">dfdt</span>    <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">%</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="n">medv</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">dfdt</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">medv</span></div>

<div class="viewcode-block" id="population_median_frequency"><a class="viewcode-back" href="../../spatial.phase.html#spatial.phase.population_median_frequency">[docs]</a><span class="k">def</span> <span class="nf">population_median_frequency</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">Fs</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Convert from phase in radians/frame to</span>
<span class="sd">    Frequency in cycles/s</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : np.complex array</span>
<span class="sd">        Phase array data</span>
<span class="sd">    Fs : int, default 1000</span>
<span class="sd">        Sampling rate in Hz</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.array</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">medv</span> <span class="o">=</span> <span class="n">population_median_phase_velocity</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">medv</span><span class="o">*</span><span class="p">(</span><span class="n">Fs</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span></div>

</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, M Rule

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>