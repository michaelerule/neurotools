from os.path import expanduser
from tools import *
from nsignaltools import *

def hsv2rgb(h,s,v):
    h,s,v = map(float,(h,s,v))
    h60 = h/60.0
    h60f = math.floor(h60)
    hi = int(h60f)%6
    f = h60-h60f
    p = v*(1-s)
    q = v*(1-f*s)
    t = v*(1-(1-f)*s)
    v = min(1.,max(0.,v))
    t = min(1.,max(0.,t))
    p = min(1.,max(0.,p))
    q = min(1.,max(0.,q))
    return ((v,t,p),(q,v,p),(p,v,t),(p,q,v),(t,p,v),(v,p,q))[hi]

def lightness(r,g,b):
    x1 = 0.30
    x2 = 0.59
    x3 = 0.11
    LRGB = array([x1,x2,x3])
    LRGB = LRGB / np.sum(LRGB)
    return dot(LRGB,(r,g,b))

def hcl2rgb(h,c,l,target = 1.0):
    x1 = 0.30
    x2 = 0.59
    x3 = 0.11
    LRGB = array([x1,x2,x3])
    LRGB = LRGB / np.sum(LRGB)
    h = h*pi/180.0
    alpha = cos(h)
    beta = sin(h)*2/sqrt(3)
    B = l - x1*(alpha+beta/2)-x2*beta
    R = alpha + beta/2+B
    G = beta+B
    RGB = array([R,G,B])
    RGB = RGB/np.max(RGB)
    luminance = dot(LRGB,RGB)
    # luminance will be off target. 
    if luminance<target:
        # the color is not as bright as it needs to be. 
        # blend in white
        WHITE = ones(3)
        lw = dot(LRGB,WHITE)
        # solve convex combination:
        # alpha*luminance+(1-alpha)*lw = target
        # a*l+lw-a*lw = t
        # a*(l-lw)+lw = t
        # a*(l-lw) = t-lw
        # a = (t-lw)/(l-lw)
        a = (target-lw)/(luminance-lw)
        RGB = a*RGB + (1-a)*WHITE
    elif luminance>target:
        # the color is too bright, blend with black
        BLACK = zeros(3)
        lb = dot(LRGB,BLACK)
        # solve the convex combination
        # a*l+(1-a)*lb = t
        # a = (t-lb)/(l-lb)
        a = (target-lb)/(luminance-lb)
        RGB = a*RGB + (1-a)*BLACK
    return clip(RGB,0,1)

def isoluminance1(h,l=.5):
    return hcl2rgb(h,1,1,target=float(l))
    
def isoluminance2(h):
    return hcl2rgb(h,1,1.0,target=.5)*(1+(h%5))/5
    
def isoluminance3(h):
    return hcl2rgb(h,1,1.0,target=.5)*(1+(h%15))/15

def isoluminance4(h):
    return hcl2rgb(h,1,1.0,target=.5)*(1+(h%60))/60
        
def lighthues(N=10,l=0.7):
    return [isoluminance1(h,l) for h in linspace(0,360,N+1)[:-1]] 

def darkhues(N=10,l=0.4):
    return [isoluminance1(h,l) for h in linspace(0,360,N+1)[:-1]] 

def medhues(N=10,l=0.6):
    return [isoluminance1(h,l) for h in linspace(0,360,N+1)[:-1]] 

'''
imshow([[isoluminance1(h) for h in range(360)]],interpolation='nearest',aspect=360)
imshow([[isoluminance1(180/pi*(h+sin(pi/3+h))) for h in linspace(0,2*pi,361)[:-1]]],interpolation='nearest',aspect=360)
imshow([[isoluminance1(180/pi*(2*(sin(-h/2+.8)**7*cos(h/2-.8))+h)) for h in linspace(0,2*pi,361)[:-1]]],interpolation='nearest',aspect=360)
'''

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.colors as mcolors

NCMAP = 360
lighthue = mcolors.ListedColormap(lighthues(NCMAP),'lighthue')
medhue   = mcolors.ListedColormap(medhues  (NCMAP),'medhue')
darkhue  = mcolors.ListedColormap(darkhues (NCMAP),'darkhue')



WHITE = ones(3)
def radl2rgb(h,l=1.0):
    '''
    Slightly more optimized HSL conversion routine.
    Saturation fixed at 1
    '''
    x1 = 0.30
    x2 = 0.59
    x3 = 0.11
    LRGB  = array([x1,x2,x3])
    alpha = cos(h)
    beta  = sin(h)*2/sqrt(3)
    B = 1.0 - x1*(alpha+beta/2)-x2*beta
    R = alpha + beta/2+B
    G = beta+B
    RGB = array([R,G,B])
    RGB = RGB/np.max(RGB)
    luminance = dot(LRGB,RGB)
    if luminance<l:
        a = (l-1)/(luminance-1)
        RGB = a*RGB + (1-a)*WHITE
    elif luminance>l:
        RGB *= l/luminance 
    return clip(RGB,0,1)

__N_HL_LUT__ = 256
__HL_LUT__ = zeros((__N_HL_LUT__,__N_HL_LUT__,3),dtype=float32)
for ih,h in enum(linspace(0,2*pi,__N_HL_LUT__+1)[:-1]):
    for il,l in enum(linspace(0,1,__N_HL_LUT__)):
        r,g,b = radl2rgb(h,l)
        __HL_LUT__[ih,il] = r,g,b

def radl2rgbLUT(h,l=1.0):
    '''
    radl2rgb backed with a limited resolution lookup table
    '''
    N = __N_HL_LUT__
    return __HL_LUT__[int(h*N/(2*pi))%N,int(l*(N-1))]

def complexHLArr2RGB(z):
    ''' Performs bulk LUT for complex numbers, avoids loops'''
    N = __N_HL_LUT__
    h = ravel(int32(angle(z)*N/(2*pi))%N)
    v = ravel(int32(clip(abs(z),0,1)*(N-1)))
    return reshape(__HL_LUT__[h,v],shape(z)+(3,))

#  imshow([[radl2rgbLUT(x*2*pi+pi*3/4,x) for x in linspace(0,1,101)]],interpolation='nearest',aspect=100)

    
    
    
    

'''
execfile(expanduser('~/Dropbox/bin/signaltools.py'))

y = arr([radl2rgbLUT(((1-x)*pi*3.+pi/4),x) for x in linspace(0,1,1000)]).T
y = arr([bandfilter(q,None,3) for q in y])
clf()
r,g,b = y
r -= np.min(r)
g -= np.min(g)
b -= np.min(b)
r = r/np.max(r)
g = g/np.max(g)
b = b/np.max(b)
imshow(arr([[r,g,b]]).transpose((0,2,1)),aspect=500)


'''
'''
#x = arr([radl2rgbLUT(-pi/6-pi*6/3*x,x) for x in linspace(0,1,1000)])
x = arr([radl2rgbLUT((1-x)*pi*2.+pi/4,x) for x in linspace(0,1,1000)])
y = arr([bandfilter(q,None,3) for q in x.T])
clf()
r,g,b = y
r = r/np.max(r)
g = g/np.max(g)
b = b/np.max(b)
luminance = mcolors.ListedColormap(arr([r,g,b]).T,'luminance')
'''



